'use strict';

var gulp   = require('gulp'),
    $      = require('gulp-load-plugins')(),
    del    = require('del'),
    notify = require('gulp-notify'),
    run    = require('run-sequence'),
    fs     = require('fs');

////////////////////
// GLOBAL OPTIONS //
////////////////////
var options = {
  production: false
};

////////////////
// BASE PATHS //
////////////////
var paths = {
  base:      {
    bower: 'bower_components',
    src:   'resources/assets',
    build: 'resources/assets/build',

    dest: {
      main:     'public/assets',
      critical: 'resources/views/_assets'
    }
  }
};

(function() {
  var knownOptions = {
    string:  'env',
    default: {env: process.env.NODE_ENV || 'local'}
  };

  var cli_args = require('minimist')(process.argv.slice(2), knownOptions);

  options.production = cli_args.env === 'production';

  if (fs.existsSync('.bowerrc')) {
    paths.base.bower = require('./.bowerrc').directory || paths.base.bower;
  }

  //////////////////
  // SOURCE PATHS //
  //////////////////
  paths.src = {
    sass: {
      critical: [
        paths.base.src + '/sass/critical/**/*.scss'
      ],
      main:     [
        paths.base.src + '/sass/main/**/*.scss'
      ]
    },
    js:   {
      critical: [
        paths.base.src + '/js/critical/**/*.js'
      ],
      main:     [
        paths.base.src + '/js/main/**/*.js'
      ]
    },
    img:  [
      paths.base.src + '/img/**/*.{png,jpg,jpeg,gif,svg}'
    ]
  };

  ////////////////
  // COPY TASKS //
  ////////////////
  paths.copy = {
    'fonts': {src: paths.base.src + '/font/**',
              dest: paths.base.dest.main + '/font'}
  };

  /////////////////////
  // BOWER LIB PATHS //
  /////////////////////
  paths.bower = {
    sass: {
      base: [
        'bourbon/app/assets/stylesheets/bourbon',
        'neat/app/assets/stylesheets/neat'
      ],
      critical: [
        'normalize-css/scss/critical'
      ],
      main: [
        'normalize-css/scss/main'
      ]
    },
    js: {
      critical: [
        'loadCSS/loadCSS',
        'loadCSS/onloadCSS',
        'loadJS/loadJS'
      ],
      main: [
        //
      ]
    },
    copy: {
      'jquery': {src: 'jquery/dist/**',
                 dest: paths.base.dest.main + '/common/js/jquery'}
    }
  };

  // ignore partials
  paths.src.sass.critical.push('!**/_*.scss');
  paths.src.sass.main.push('!**/_*.scss');
  paths.src.js.critical.push('!**/_*.js');
  paths.src.js.main.push('!**/_*.js');
})();

///////////
// UTILS // *** DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING ***
///////////
var utils = {
  ensureBuildDir: function() {
    if (!fs.existsSync(paths.base.build)) fs.mkdirSync(paths.base.build);
  },

  buildFilePath: function(name) {
    return paths.base.build + '/' + name;
  },

  isBuildFileClean: function(name) {
    var path = this.buildFilePath(name);

    if (!fs.existsSync(path)) return false;

    var gulpfile_stat = fs.statSync(__filename),
        build_file_stat = fs.statSync(path);

    return build_file_stat.mtime.getTime() >= gulpfile_stat.mtime.getTime();
  },

  writeBuildFile: function(name, content) {
    this.ensureBuildDir();
    var path = this.buildFilePath(name);

    fs.writeFileSync(path, content.join('\n'));
  },

  makeBowerBuildFile: function (name, ext, lines, formatter) {
    if (utils.isBuildFileClean('_bower_' + name + '.' + ext)) return;

    var contents = [];

    contents.push('// DO NOT EDIT THIS FILE. IT IS AUTO-GENERATED AND WILL BE OVERWRITTEN BY THE BUILD SYSTEM.');
    contents.push('');

    for (var q = 0; q < lines.length; q++) {
      if (typeof lines[q] === 'function') {
        contents.push(lines[q]());
      } else {
        lines[q] += '';
        if (!lines[q].match(new RegExp('\\.' + ext + '$'))) lines[q] += '.' + ext;
        contents.push(formatter('../../../' + paths.base.bower + '/' + lines[q]));
      }
    }

    utils.writeBuildFile('_bower_' + name + '.' + ext, contents);
  },

  errorCallback: function (label) {
    return function (err) {
      var path = (err.fileName || err.file),
          line = (err.lineNumber || err.line),
          column = (err.column || 0),
          relative = path.substr(__dirname.length + 1),
          location = relative + ' @ ' + line + ':' + column;

      var message = err.message;
      message = message.replace(new RegExp('\\W*' + path + '\\W*'), '');
      message = message.replace(new RegExp('\\W*' + relative + '\\W*'), '');
      message = message.replace(new RegExp('\\W*' + line + '([^0-9 ]' + column + ')?\\W*'), '');

      console.error('***');
      console.error(label + ' ERROR!!');
      console.error(message);
      console.error(location);
      console.error('***');

      if (options.production) {
        throw err;
      } else {
        notify.onError(function() {
          return label + ' ERROR!!\n'
              + message + '\n'
              + location;
        }).call(this, err);

        this.emit('end');
      }
    }
  }
};

/**
 * Copies bower components' public assets to publicly-accessible paths
 */
gulp.task('bower:copy', function(cb) {
  var tasks = [];

  for (var key in paths.bower.copy) {
    if (!paths.bower.copy.hasOwnProperty(key)) continue;

    gulp.task('bower:copy:' + key, (function (key) { return function () {
      var lib = paths.bower.copy[key];

      var src = lib.src;
      if (typeof src === 'string') src = [src];
      for (var q = 0; q < src.length; q++) {
        src[q] = paths.base.bower + '/' + src[q];
      }

      return gulp.src(src).pipe($.newer(lib.dest)).pipe(gulp.dest(lib.dest));
    };})(key));

    tasks.push('bower:copy:' + key)
  }

  if (tasks.length) run(tasks, cb);
  else if (cb) cb();
});

/**
 * Creates the bower import files for sass
 *
 * Creates resources/build/_bower_XXX.scss
 */
gulp.task('bower:sass', function(cb) {
  var tasks = [];

  for (var key in paths.bower.sass) {
    if (!paths.bower.sass.hasOwnProperty(key)) continue;

    gulp.task('bower:sass:' + key, (function (key) { return function () {
      utils.makeBowerBuildFile(key, 'scss', paths.bower.sass[key], function (path) {
        return '@import "' + path + '";';
      });
    };})(key));

    tasks.push('bower:sass:' + key);
  }

  if (tasks.length) run(tasks, cb);
  else if (cb) cb();
});

/**
 * Creates the bower import files for js
 *
 * Creates resources/build/_bower_XXX.js
 */
gulp.task('bower:js', function(cb) {
  var tasks = [];

  for (var key in paths.bower.js) {
    if (!paths.bower.js.hasOwnProperty(key)) continue;

    gulp.task('bower:js:' + key, (function (key) { return function () {
      utils.makeBowerBuildFile(key, 'js', paths.bower.js[key], function (path) {
        return '//= include ' + path;
      });
    };})(key));

    tasks.push('bower:js:' + key);
  }

  if (tasks.length) run(tasks, cb);
  else if (cb) cb();
});

/**
 * Creates the bower versions import file for js
 *
 * Creates resources/build/_bower_versions.js
 */
gulp.task('bower:versions', function() {
  return gulp.src(paths.base.bower + '/*/.bower.json')
      .pipe($.bowerVersions({variable: 'BowerComponents'}))
      .pipe(gulp.dest(paths.base.build + '/_bower_versions.js'));
});

/**
 * Copies .css files to .scss files in bower components so they can be imported in sass
 */
gulp.task('bower:sass:css_to_scss', function() {
  return gulp.src([paths.base.bower + '/**/*.css', '!' + paths.base.bower + '/**/*.min.css'], {base: paths.base.bower})
      .pipe($.newer({dest: paths.base.bower, ext: '.scss'}))
      .pipe($.rename({extname: '.scss'}))
      .pipe(gulp.dest(paths.base.bower));
});

/**
 * Compiles critical sass stylesheets
 */
gulp.task('sass:critical', function() {
  return gulp.src(paths.src.sass.critical, {base: paths.base.src})
      .pipe($.sourcemaps.init())
      .pipe($.sass({
        outputStyle: options.production ? 'compressed' : 'nested'
      }))
      .on('error', utils.errorCallback('SASS'))
      .pipe($.if(!options.production, $.sourcemaps.write({sourceRoot: '/' + paths.base.src})))
      .pipe($.rename(function (path) {
        path.dirname = path.dirname.replace(/(\/|^)sass(\/|$)/, '/css/').replace(/(\/|^)critical(\/|$)/, '/');
        path.basename += '_css';
        path.extname = '.twig';
      }))
      .pipe(gulp.dest(paths.base.dest.critical))
      .pipe($.size({title: 'critical css'}));
});

/**
 * Compiles async sass stylesheets
 */
gulp.task('sass:main', function() {
  return gulp.src(paths.src.sass.main, {base: paths.base.src})
      .pipe($.sourcemaps.init())
      .pipe($.sass({
        outputStyle: options.production ? 'compressed' : 'nested'
      }))
      .on('error', utils.errorCallback('SASS'))
      .pipe($.rename(function (path) {
        path.dirname = path.dirname.replace(/(\/|^)sass(\/|$)/, '/css/').replace(/(\/|^)main(\/|$)/, '/');
        path.extname = '.min.css';
      }))
      .pipe($.if(!options.production, $.sourcemaps.write('.', {
        sourceRoot: function(file) {
          return file.path.replace(/^resources/, '').substr(1).replace(/[^\/]+/ig, '..') + '/../resources/';
        }
      })))
      .pipe(gulp.dest(paths.base.dest.main))
      .pipe($.size({title: 'main css'}));
});

/**
 * Compiles critical js scripts
 */
gulp.task('js:critical', function() {
  return gulp.src(paths.src.js.critical, {base: paths.base.src})
      .pipe($.cache($.include()))
      .pipe($.cache($.uglify({
        mangle: !!options.production
      })))
      .on('error', utils.errorCallback('JS'))
      .pipe($.rename(function (path) {
        path.dirname = path.dirname.replace(/(\/|^)critical(\/|$)/, '/');
        path.basename += '_js';
        path.extname = '.twig';
      }))
      .pipe(gulp.dest(paths.base.dest.critical))
      .pipe($.size({title: 'critical js'}));
});

/**
 * Compiles async js scripts
 */
gulp.task('js:main', function() {
  return gulp.src(paths.src.js.main, {base: paths.base.src})
      .pipe($.sourcemaps.init())
      .pipe($.cache($.include()))
      .pipe($.cache($.uglify({
        mangle: !!options.production
      })))
      .on('error', utils.errorCallback('JS'))
      .pipe($.rename(function (path) {
        path.dirname = path.dirname.replace(/(\/|^)main(\/|$)/, '/');
        path.extname = '.min.js';
      }))
      .pipe($.if(!options.production, $.sourcemaps.write('.', {
        sourceRoot: function(file) {
          return file.path.replace(/^resources/, '').substr(1).replace(/[^\/]+/ig, '..') + '/../resources/';
        }
      })))
      .pipe(gulp.dest(paths.base.dest.main))
      .pipe($.size({title: 'main js'}));
});

/**
 * Builds custom modernizr script
 *
 * Creates resources/build/modernizr.js
 */
gulp.task('modernizr', function() {
  return gulp.src([paths.base.src + '/**/*.scss', paths.base.src + '/**/*.js', '!' + paths.base.src + '/build/_modernizr.js'])
      .pipe($.modernizr('_modernizr.js', {
        paths: ['setClasses', 'addTest', 'html5printshiv', 'testProp', 'fnBind']
      }))
      .pipe(gulp.dest(paths.base.src + '/build'));
});

/**
 * Copies bower components' public assets to publicly-accessible paths
 */
gulp.task('copy', function(cb) {
  var tasks = [];

  for (var key in paths.copy) {
    if (!paths.copy.hasOwnProperty(key)) continue;

    gulp.task('copy:' + key, (function (key) { return function () {
      var task = paths.copy[key];

      var src = task.src;
      if (typeof src === 'string') src = [src];
      src.push('!**/.git*');

      return gulp.src(src).pipe($.newer(task.dest)).pipe(gulp.dest(task.dest));
    };})(key));

    tasks.push('copy:' + key)
  }

  if (tasks.length) run(tasks, cb);
  else if (cb) cb();
});

/**
 * Compresses images
 */
gulp.task('img', function() {
  return gulp.src(paths.src.img, {base: paths.base.src})
      .pipe($.cache($.imagemin({
        progressive: true,
        interlaced:  true
      })))
      .pipe(gulp.dest(paths.base.dest.main))
      .pipe($.size({title: 'images'}));
});

/**
 * Compiles all CSS (critical and async)
 */
gulp.task('css', ['bower:sass', 'bower:sass:css_to_scss'], function(cb) {
  run(['sass:critical', 'sass:main'], cb);
});

/**
 * Compiles all JS (critical and async)
 */
gulp.task('js', ['bower:js', 'bower:versions', 'modernizr'], function(cb) {
  run(['js:critical', 'js:main'], cb);
});

/**
 * Clears the gulp-cache cache
 */
gulp.task('clean:cache', function (cb) {
  return $.cache.clearAll(cb);
});

/**
 * Cleans all built artifacts
 */
gulp.task('clean:files', function () {
  var cleanPaths = [
    '.tmp',
    paths.base.dest.critical,
    paths.base.dest.main,
    paths.base.build
  ];

  for (var key in paths.copy) {
    if (!paths.copy.hasOwnProperty(key)) continue;

    cleanPaths.push(paths.copy[key].dest);
  }

  return del(cleanPaths, {dot: true});
});

/**
 * Performs a complete clean
 */
gulp.task('clean', function(cb) {
  run(['clean:cache', 'clean:files'], cb);
});

/**
 * Runs all compile tasks (CSS and JS)
 */
gulp.task('compile', function(cb) {
  run(['css', 'js'], cb);
});

gulp.task('default', options.production ? ['clean'] : [], function(cb) {
  run(['copy', 'bower:copy', 'img', 'compile'], cb);
});

gulp.task('watch', ['default'], function() {
  gulp.watch(paths.base.src + '/**/*.js', ['js']);
  gulp.watch(paths.base.src + '/**/*.scss', ['css']);
  gulp.watch(paths.base.src + '/**/*.{png,jpg,jpeg,gif,svg}', ['img']);
});
